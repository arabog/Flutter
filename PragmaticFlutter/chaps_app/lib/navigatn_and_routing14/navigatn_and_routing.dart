/*
Navigation and Routing
In this chapter, we will learn about the three types of navigation 
and routing to implement navigation from the BookListing homepage 
to the BookDetailsPage screen. The BookDetailsPage page only 
displays the book details

SIMPLE BookDetailsPage SCREEN
In this section, you will learn to build a basic secondary page 
widget – BookDetailsPage, which is used as a placeholder to 
understand navigation and routing concepts in Flutter application.

The BookDetailsPage is a StatelessWidget with two children 
widgets: AppBar and Center. The AppBar widget displays the 
book’s title, and the Center widget is assigned to the `body` 
property for the Scaffold widget. This Center widget has a 
child Text widget to display the book’s detailed description.

import 'package:flutter/material.dart';
import 'book.dart';


class BookDetailsPage extends StatelessWidget {
	final BookModel book;

	const BookDetailsPage({Key key, this.book}) : super(key: key);

	@override
	Widget build(BuildContext context) {
		return Scaffold(
			appBar: AppBar(
				title: Text(book.volumeInfo.title),
			),
			
			body: Center(
				child: Text(book.volumeInfo.description),
			),
		);
	}
}

The data structure BookModel was constructed in the chapter 
(Chapter 13: Data Modeling) from the Books API’s JSON response. 
The BookDetailsPage requires the currently selected book item 
information passed along to be able to render its title and description. 
The `book` object of BookModel data type provides the book’s title 
information as `book.volumeInfo.title`, and its description is 
available as `book.volumeInfo.description`. At this point, we 
display only the title and description in the book details page.

NAVIGATOR WIDGET
The Flutter framework implements navigation across multiple 
pages using the Navigator (Navigator class) widget. It’s a widget 
to manage children widgets using a stack discipline. There are 
three different ways to implement navigation in the Flutter 
application.

Direct Navigation: 
The direct navigation is also known as Unnamed Routing. It 
is implemented with the help of MaterialPageRoute
(MaterialPageRoute<T> class).

Static Navigation: 
The static navigation is a type of Named Routing. It is
implemented by assigning a map of routes to MaterialApp 
`routes` (routes property) property. The routes property acts 
like the application’s top-level routing table. The route name 
is pushed using Navigator.pushNamed(...). The routing table 
decides which route will map to what widget.

Dynamic Navigation: 
The dynamic navigation is a type of Named Routing as well. In 
this navigation type, routes are generated by implementing the 
onGenerateRoute (onGenerateRoute property) callback in the
MaterialApp class. It’s a function that provides the routes dynamically.
This routing function is assigned to the onGenerateRoute property
of MaterialApp, as mentioned earlier. The route name is pushed using
Navigator.pushNamed(...) similar to static navigation.

DIRECT NAVIGATION
Direct navigation is also known as unnamed routing. As mentioned 
earlier, it is implemented using MaterialPageRoute. The 
MaterialPageRoutes is pushed directly to the navigator widget stack. 
This approach can contribute to duplicate and boilerplate code across 
multiple pages. This boilerplate code multiplies with growing 
screens/pages. It is challenging to keep track of logic wrapped around 
these routes in a commonplace since it spreads around multiple classes.
Let’s implement this type of navigation in our BooksApp for navigating 
from the BookListing page to BookDetailsPage.


Entry Point
The MaterialApp assigns the BooksListing screen to its home property.

class BooksApp extends StatelessWidget {
	@override
	Widget build(BuildContext context) {
		//Using Direct Navigation (un-named routing)
		return MaterialApp(
			debugShowCheckedModeBanner: false,

			home: BooksListing(),
		);
	}
}


Navigation Implementation
This routing is implemented using Navigator.push() 
(push<T extends Object> method) method. The 
MaterialPageRoute (MaterialPageRoute<T> class) is pushed 
on the Navigator (Navigator class). The Navigator is a widget 
that manages a set of child widgets as a stack. These child 
widgets are pages or screens pushed on the Navigator widget. 
The Navigator widget refers to these children as Route 
(Route class) objects.

DETECTING GESTURE
The navigation is initiated from the user activity on the homepage 
screen. That means the BookListing page list items need to be 
interacted with to navigate to its detailed page. The GestureDetector 
(GestureDetector class) widget is used to detect the gestures. It 
handles the taps on the listing items using its `onTap:` property.

class BooksListing extends StatefulWidget {
	@override
	_BooksListingState createState() => _BooksListingState();
}


class _BooksListingState extends State<BooksListing> {
	List<BookModel> booksListing;
	...
	@override
	Widget build(BuildContext context) {
		return Scaffold(
			...
			body: ListView.builder(
				itemCount: booksListing == null ? 0 : booksListing.length,

				itemBuilder: (context, index) {
					//Passing bookModelObj to BookTile widget
					return GestureDetector(
						child: BookTile(bookModelObj: booksListing[index]),
						
						onTap: () {}
					);
				},
			),
		);
	}
}

PASSING DATA
The MaterialPageRoute uses a builder to build the primary contents 
of the route (page/screen). The `book` object is passed as an argument 
to the BookDetailsPage widget.
```
onTap: () {
	Navigator.of(context).push(
		MaterialPageRoute(
			builder: (context) => BookDetailsPage(
				book: booksListing[index],
			),
		),
	);
},

Tip
The above code can also be written in one line without using curly braces.
```
onTap: () =>
	Navigator.of(context).push(
	MaterialPageRoute(
		builder: (context) => BookDetailsPage(
			book: booksListing[index],
		),
	),
)

STATIC NAVIGATION
In a static navigation application’s top-level routing table is 
implemented using a Map (Map<K, V> class) of routes 
(pages/screens). This routing table is assigned to MaterialApp 
routes (routes property) property. The route names for pages are 
pushed using Navigator.pushNamed(...) (pushNamed<T extends Object>
method). This routing is known as Named Routing because each page 
is given a unique name, which is pushed on the Navigator widget.

The MaterialApp and WidgetApp provide the routes property. This 
property enables assigning routes as Map<String, WidgetBuilder>. 
This option works better when there are not many logical steps 
wrapped around the routes. For example, authentication or verification 
related code wrapped around the logic for navigating to a particular 
page. In this type of navigation, only the app’s global data can be 
passed on to the second page.

Entry Point
The static navigation provides two ways to assign the initial page 
– BooksListing widget. One option is to assign BooksListing widget 
to the home property.
Second option is to assign a route Map containing </, BooksListing()> 
entry to routes property. The ‘/’ stands for the home page mapping.

//The booksListing data is available global to app
List<BookModel> booksListing;

class BooksApp extends StatelessWidget {
	@override
	Widget build(BuildContext context) {
		//Using Static Navigation (Named Routing)
		return MaterialApp(
			debugShowCheckedModeBanner: false,

			//home: BooksListing(),

			//Named-Routing using Map routing-table
			routes: <String, WidgetBuilder>{
				'/': (BuildContext context) => BooksListing(),

				'/details': (BuildContext context) => BookDetailsPage(
					book: booksListing[0],
				),
			},
		);
	}
}

In static navigation, the routing table is assigned statically. That 
means any object can be passed in the routing map only. This 
requires data to be available at the top-level. We need to pass the 
`book` object to the BookDetailsPage for the `/details` route name. 

As you can see that this value is static and cannot be changed with 
the update in the book selection in the BookListing book items list. 
The value is retrieved by accessing `List<BookModel> booksListing`,
which gets updated after the REST API response is returned. For the 
`/details` route, only one book object is assigned for the lifecycle of 
the app as `book: booksListing[0]`. This causes to show the same 
book’s details for every book displayed in the BookListing widget.

Navigation Implementation
All routes/pages have entries in the routing table above. The Map 
entry ‘</details, BookDetailsPage()>‘is added to navigate to the 
BookDetailsPage screen.

The ' /details' is the alias/name to the BookDetailsPage screen. 
This name is pushed on the Navigator widget using 
Navigator.pushNamed (pushNamed<T extends Object> method).

DETECTING GESTURE
The navigation is initiated from the user activity on the homepage 
screen, similar to a direct navigation example. The GestureDetector 
widget is used to detect the gestures. It handles the tap gesture on the 
listing with 'onTap: ' property. Please note the named route ' /details' 
are pushed on the Navigator stack. This route is declared in the 
MaterialApp routing table.

onTap: () => Navigator.pushNamed(context, '/details')

PASSING DATA
As we saw earlier, the data can be passed to the BookDetailsPage() 
at the top-level only when the routes are assigned to routes property. 
In this case, only globally available data can be passed to another 
widget. In this implementation, only the first item `booksListing[0]` 
detail page is available for any selection on the homepage.

DYNAMIC NAVIGATION
In dynamic navigation, routes are generated dynamically with the 
help of a function. This function implements the onGenerateRoute 
(onGenerateRoute property) callback in the MaterialApp class. 
This is a type of Named Routing that makes use of onGenerateRoute 
property. 

The MaterialApp and WidgetApp provide the onGenerateRoute 
property to assign the callback function, say generateRoute 
returning a route. It allows the data to pass using RouteSettings 
(RouteSettings class). It carries the data to help construct a 
Route (Route class).

Any authorization or verification logic can be extracted to a single 
place. This routing provides the option to show a default page 
when a route or match is not found. In our BooksApp, we will 
use the `PageNotFound` widget when no route is matched. It’s 
a simple page that displays the message that the requested page 
is not available.

Entry Point
The entry page BookListing is assigned to home property. The 
initialRoute property can be used to set the beginning route/page. 
The generateRoute callback function handles the navigational logic.

class BooksApp extends StatelessWidget {
	@override
	Widget build(BuildContext context) {
		//Using Dynamic Navigation (Named Routing)
		return MaterialApp(
			debugShowCheckedModeBanner: false,

			home: BooksListing(),

			//Named with onGenerateRoute
			initialRoute: '/', onGenerateRoute: generateRoute,
		);
	}
}


THE generateRoute() FUNCTION
The generateRoute() function takes the RouteSettings as an 
argument, which allows sending data along. The arguments 
property on the RouteSettings object retrieves any arguments 
sent with the widget.

Route<dynamic> generateRoute(RouteSettings routeSettings) {
	final args = routeSettings.arguments;

	switch (routeSettings.name) {
		case '/':
			return MaterialPageRoute(
				builder: (context) => BooksListing(),
			);

		case '/details':
			if (args is BookModel) {
				return MaterialPageRoute(
					builder: (context) => BookDetailsPage(
						book: args,
					),
				);
			}

			return MaterialPageRoute(
				builder: (context) => PageNotFound(),
			);

		default:
			return MaterialPageRoute(
				builder: (context) => PageNotFound(),
			);
	}
}

Navigation Implementation
The Navigator uses the Route object to represent the page/screen. 
The generateRoute() function returns the appropriate route based 
on the matching name. The RouteSettings is useful in passing around 
these route names and arguments, if any. The route name is extracted 
using routeSettings.name. The arguments can be extracted using 
routeSettings.arguments. When no match is found, a common default 
page is shown to display the appropriate message.

DETECTING GESTURE
The navigation is initiated from the user activity on the homepage 
screen, similar to direct and static navigation examples. The 
GestureDetector widget is used to detect the gestures. It handles 
the tap gesture on the listing with `onTap: ` property.

PASSING DATA
Dynamic navigation uses named-routing as well. This routing allows 
passing selected book object `booksListing[index]` as an argument 
to generateRoute() callback function. The generateRoute() function 
extracts the route name and its arguments using the RouteSettings 
object. Refer to generateRoute() to understand extracting route 
names and arguments from the RouteSettings object.

onTap: () =>
	Navigator.pushNamed(
	context,

	'/details',
	
	arguments: booksListing[index],
)














*/ 