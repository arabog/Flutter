/*
Preparing Database Using Moor
First, we’ll use Moor to prepare a database to save `themeId` 
and `themeName`. The active theme’s id will be saved in the 
database table. This table will have only one entry at a given 
time. When the theme switches from light to dark, the older 
entry will be deleted, and a newly selected theme’s id will be 
added to this table. I kept it simple on purpose to demonstrate 
how Moor can be integrated in your app.

The `ThemePrefs` class extends `Table`. ThemePrefs table 
contains only two fields: theme _ id to save id for the theme 
and another field themeName for saving name.

class ThemePrefs extends Table {
	IntColumn get themeId => integer() ();

	TextColumn get themeName => text() ();
}

It will generate a table called theme _ prefs for us. The rows 
of that table will be represented by a class called `ThemePref` 
auto generated by `moor _ generator` plugin.

The following part actually prepares the database table. 
This is the class where migration strategy is described. 
It resets the tables, and makes the light theme default in 
case of first launch or upgrade.

@UseMoor(tables: [ThemePrefs])

class MyDatabase extends _$MyDatabase {
	@override
	MigrationStrategy get migration {...}
}

There is one method to activate the theme. It adds the 
current theme’s index/id to the table.

void activateTheme(AppThemes theme) {
	ThemePref pref = 
	ThemePref(themeId: theme.index, themeName: theme.toString());
	
	into(themePrefs).insert(pref);
}

The other method `deactivateTheme(int i)` removes the entry 
from the table for the given `theme _ id`.

void deactivateTheme(int i) =>
(delete(themePrefs)..where((t) => t.themeId.equals(i))).go();

The method `themeIdExists(.)` checks if the entry for given 
`theme _ id` already exists, and returns a boolean.


Stream<bool> themeIdExists(int id) {
	return select(themePrefs)
	.watch()
	.map((prefs) => prefs.any((pref) => pref.themeId == id));
}

The `getActiveTheme()` queries the table and returns the only 
available row. Remember there’s only one row for the active 
theme in the whole table. By the way, this may not be the good 
use of a database to just store one entry. I chose to keep this
way to understand the database integration in a Flutter app.

Future<ThemePref> getActiveTheme() {
	return select(themePrefs).getSingle();
}

Let’s take a look at the database file: themes_pref.dart below:

import 'package:moor/moor.dart';
import '../themes.dart';
part 'theme_prefs.g.dart';

It will generate a table called "theme_prefs" for us. The rows of 
that table will be represented by a class called "ThemePref".

class ThemePrefs extends Table {
	// AppThemes id
	IntColumn get themeId => integer()();
	TextColumn get themeName => text()();
}

// Moor prepares database table
@UseMoor(tables: [ThemePrefs])
class MyDatabase extends _$MyDatabase {
	MyDatabase(QueryExecutor e) : super(e);

	// Bump schemaVersion whenever there's change.
	@override
	int get schemaVersion => 1;

	Keeping it simple reset the database whenever there's an update.
	Add light theme as default theme after first launch and
	@override
	MigrationStrategy get migration {
		return MigrationStrategy(onCreate: (Migrator m) {
			return m.createAll();
		}, 
		
		onUpgrade: (Migrator m, int from, int to) async {
			m.deleteTable(themePrefs.actualTableName);

			m.createAll();
		}, 
		
		beforeOpen: (details) async {
			if (details.wasCreated) {
				await into(themePrefs).insert(ThemePrefsCompanion(
					themeId: const Value(0),

					themeName: Value(AppThemes.light.toString()),
				));
			}
		});
	}

	void activateTheme(AppThemes theme) {
		ThemePref pref =
		ThemePref(themeId: theme.index, themeName: theme.toString());

		into(themePrefs).insert(pref);
	}

	void deactivateTheme(int i) =>
		(delete(themePrefs)..where((t) => t.themeId.equals(i))).go();


	The stream will automatically emit new items whenever the 
	underlying data changes.
	Stream<bool> themeIdExists(int id) {
		return select(themePrefs)
		.watch()
		.map((prefs) => prefs.any((pref) => pref.themeId == id));
	}

	Future<ThemePref> getActiveTheme() {
		return select(themePrefs).getSingle();
	}
}


Please note that this line ‘part 'theme _ prefs.g.dart';’ will show 
an error in the beginning because this file doesn’t exist yet. You’ll 
need to execute following command to generate sqlite bindings:

flutter packages pub run build_runner build--delete-conflicting-outputs


import 'package:moor/moor.dart';
import '../../flutter_themes10/themes.dart';
part 'theme_prefs.g.dart';

// It will generate a table called "theme_prefs" for us. The rows of 
// that table will be represented by a class called "ThemePref".

class ThemePrefs extends Table {
	// AppThemes id
	IntColumn get themeId => integer()();
	TextColumn get themeName => text()();
}


// Moor prepares database table
@UseMoor(tables: [ThemePrefs])
class MyDatabase extends _$MyDatabase {
	MyDatabase(QueryExecutor e) : super(e);

	// Bump schemaVersion whenever there's change.
	@override
	int get schemaVersion => 1;

	// Keeping it simple reset the database whenever there's an update.
	// Add light theme as default theme after first launch and upgrade
	@override
	MigrationStrategy get migration {
		return MigrationStrategy(onCreate: (Migrator m) {
			return m.createAll();
		}, 
		
		onUpgrade: (Migrator m, int from, int to) async {
			m.deleteTable(themePrefs.actualTableName);

			m.createAll();
		}, 
		
		beforeOpen: (details) async {
			if (details.wasCreated) {
				await into(themePrefs).insert(ThemePrefsCompanion(
					themeId: const Value(0),

					themeName: Value(AppThemes.light.toString()),
				));
			}
		});
	}

	void activateTheme(AppThemes theme) {
		ThemePref pref =
		ThemePref(themeId: theme.index, themeName: theme.toString());

		into(themePrefs).insert(pref);
	}

	void deactivateTheme(int i) =>
		(delete(themePrefs)..where((t) => t.themeId.equals(i))).go();


	// The stream will automatically emit new items whenever the 
	// underlying data changes.
	Stream<bool> themeIdExists(int id) {
		return select(themePrefs)
		.watch()
		.map((prefs) => prefs.any((pref) => pref.themeId == id));
	}

	Future<ThemePref> getActiveTheme() {
		return select(themePrefs).getSingle();
	}
}


Cross -Platform Database Implementation ( s )
Different platforms have different implementations for databases. 
We need to create a shared code that can pull in the correct database 
implementation for a given platform. We’ll create one file to write 
shared code, say shared.dart. This file is responsible for picking 
the platform-specific database implementation.

File: shared.dart
export 'unsupported.dart'
	if (dart.library.html) 'web.dart'
	if (dart.library.io) 'native.dart';

When the Flutter application is running on Android, iOS, desktop 
(Linux/Windows/MacOS) platforms, mobile.dart implementation 
is picked. For Flutter Web, web.dart is chosen by the platform. 
The unsupported.dart implementation is picked for everything else.

File: native.dart
```
import 'dart:io';
import 'package:moor/ffi.dart';
import 'package:moor/moor.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart' as paths;
import '../theme_prefs.dart';

//Note: Implementation borrowed from template project: 
// https://github.com/appleeducate/moor_shared

MyDatabase constructDb({bool logStatements = false}) {
	if (Platform.isIOS || Platform.isAndroid) {
		final executor = LazyDatabase(() async {
			final dataDir = await paths.getApplicationDocumentsDirectory();
			
			final dbFile = File(p.join(dataDir.path, 'db.sqlite'));
			
			return VmDatabase(dbFile, logStatements: logStatements);
		});

		return MyDatabase(executor);
	}


	if (Platform.isMacOS || Platform.isLinux) {
		final file = File('db.sqlite');
		return MyDatabase(VmDatabase(file, logStatements: logStatements));
	}

	if (Platform.isWindows) {
		final file = File('db.sqlite');

		return MyDatabase(VmDatabase(file, logStatements: logStatements));
	}

	return MyDatabase(VmDatabase.memory(logStatements: logStatements));
}

File: web.dart
import 'package:moor/moor_web.dart';
import '../theme_prefs.dart';

MyDatabase constructDb({bool logStatements = false}) {
	return MyDatabase(WebDatabase('db', logStatements:logStatements));
}

File: unsupported.dart
import '../theme_prefs.dart';
MyDatabase constructDb({bool logStatements = false}) {
	throw 'Platform not supported';
}


*/ 

// continue from 175

