flutter create recipes

cd recipes
flutter run


flutter clean

for Gradle task 'assembleDebug'... issue at startup:
flutter doctor --android-licenses

https://www.raywenderlich.com/books/flutter-apprentice/v2.0/chapters/6-interactive-widgets

https://www.raywenderlich.com/books/flutter-apprentice/v2.0/chapters/5-scrollable-widgets

https://forums.raywenderlich.com/c/books/flutter-apprentice

Adding a package dependency to an app
From the terminal: Run flutter pub get . 

try:

flutter upgrade
then:

flutter run -v


Every widget’s build() method takes a BuildContext 
as an argument. The build context tells you where 
you are in the tree of widgets. You can access the 
element for any widget through the BuildContext

Column and Row widgets are like ListView but without the scroll view.

The main axis always corresponds to the scroll direction!

If your scroll direction is horizontal, you can think of this(main axis) as a Row. The main axis represents the horizontal direction

If your scroll direction is vertical, you can think of it(main axis) as a Column. The main axis represents the vertical direction

Grid delegates help figure out the spacing and the number of columns to use to lay out the children in a GridView.


Convert Stateless to Stateful Widget: 
do ds in adroid studio
Open author_card.dart and right-click on AuthorCard. 
Then click Show Context Actions from the menu that pops up:


Note: Remember that the purpose of a barrel file is to group common Dart files together. This allows you to group classes that are commonly used together so you only have to import a single file — in this case, models.dart.

Tip: You should only wrap a Consumer around widgets that need it. For example, wrapping a consumer widget at the top level would force it to rebuild the entire tree!


A deep link is a URL that navigates to a specific destination in your mobile app. You
can think of deep links like a URL address you enter into a web browser to go to a
specific page of a website rather than the home page.

For deep links to work, you need to do two key things: convert a URL to an app state
and convert an app state to a URL

navigation state is just a user-defined data type. It
converts a URL string into a proper data type.

AppLink is the intermediary object between a URL string and your app state.

Converting a URL to an app state
When the user enters a new URL on the web or triggers a deep link on mobile,
RouteInformationProvider notifies RouteInformationParser that there’s a new
route

Deep linking to the Home screen:
Enter the following in your terminal:
xcrun simctl openurl booted 'fooderlich://raywenderlich.com/
home?tab=1'

Deep linking to the Profile screen:
xcrun simctl openurl booted 'fooderlich://raywenderlich.com/
profile'

Deep linking to create a new item:
xcrun simctl openurl booted 'fooderlich://raywenderlich.com/
item'


chapter 9
• cached_network_image: Download and cache the images you’ll use in the app.
• flutter_slidable: Build a widget that lets the user slide a card left and right to
perform different actions, like deleting a saved recipe.
• flutter_svg: Load SVG images without the need to use a program to convert them
to vector files.

Saving data
There are three primary ways to save data to your device:
1. Write formatted data, like JSON, to a file.
2. Use a library or plugin to write simple data to a shared location.
3. Use a SQLite database.

Why save small bits of data?
Note that this simple data saved to a shared location is lost when the user uninstalls
the app.

The shared_preferences plugin
shared_preferences is a Flutter plugin that allows you to save data in a key-value
format so you can easily retrieve it later.

it only supports saving simple properties like strings,
numbers, and boolean values.

Be aware that shared_preferences is not a good fit to store sensitive data. e.g store passwords or access tokens

Running code in the background
Most modern UI toolkits have a main thread that runs the UI code. Any code that takes a long time needs to run on a different thread or process so it doesn’t block the UI. Dart uses a technique similar to JavaScript to achieve this. The language includes these two keywords:
• async
• await
async marks a method or code section as asynchronous. You then use the await keyword inside that method to wait until an asynchronous process finishes in the background.

Dart also has a class named Future , which indicates that the method promises a future result. SharedPreferences.getInstance() returns Future<SharedPreferences> , which you use to retrieve an instance of the SharedPreferences class